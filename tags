!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
,cd	nvim/init.vim	/^nnoremap ,cd :cd %:p:h<CR>:pwd<CR>$/;"	m
:bn	nvim/init.vim	/^nmap :bn :BufSurfForward<cr>$/;"	m
:bp	nvim/init.vim	/^nmap :bp :BufSurfBack<cr>$/;"	m
:sp	nvim/init.vim	/^nmap :sp :rightbelow sp<cr>$/;"	m
<C-b>	nvim/init.vim	/^nmap <C-b> :NERDTreeToggle<cr>$/;"	m
<C-f>	nvim/init.vim	/^nmap <C-f> :FZF<cr>$/;"	m
<C-r>	nvim/init.vim	/^map <C-r> :CtrlPBufTag<cr>$/;"	m
<D-p>	nvim/init.vim	/^map <D-p> :CtrlP<cr>$/;"	m
<F8>	nvim/init.vim	/^nmap <F8> :TagbarToggle<CR>$/;"	m
<F9>	nvim/init.vim	/^nmap <F9> :ALEToggleFixer<CR>$/;"	m
<Tab>	nvim/init.vim	/^inoremap <expr> <Tab> pumvisible() ? coc#_select_confirm() : "<Tab>"$/;"	m
<leader>c	nvim/init.vim	/^nmap <leader>c :!composer install <cr>$/;"	m
<leader>gca	nvim/init.vim	/^nmap <leader>gca :Gcommit -a -S<cr>$/;"	m
<leader>gl	nvim/init.vim	/^nmap <leader>gl :Gpull<cr>$/;"	m
<leader>gp	nvim/init.vim	/^nmap <leader>gp :Gpush<cr>$/;"	m
<leader>gst	nvim/init.vim	/^nmap <leader>gst :Gstatus<cr>$/;"	m
<leader>q	nvim/init.vim	/^nmap <leader>q :q<cr>$/;"	m
<leader>q!	nvim/init.vim	/^nmap <leader>q! :q!<cr>$/;"	m
<leader>qa	nvim/init.vim	/^nmap <leader>qa :qa<cr>$/;"	m
<leader>w	nvim/init.vim	/^nmap <leader>w :w!<cr>$/;"	m
<leader>z	nvim/init.vim	/^nmap <leader>z :ZenMode <cr>$/;"	m
AG_COMPRESS	nvim/ag/src/decompress.h	/^    AG_COMPRESS,$/;"	e	enum:__anon5
AG_GZIP	nvim/ag/src/decompress.h	/^    AG_GZIP,$/;"	e	enum:__anon5
AG_NO_COMPRESSION	nvim/ag/src/decompress.h	/^    AG_NO_COMPRESSION,$/;"	e	enum:__anon5
AG_XZ	nvim/ag/src/decompress.h	/^    AG_XZ,$/;"	e	enum:__anon5
AG_ZIP	nvim/ag/src/decompress.h	/^    AG_ZIP,$/;"	e	enum:__anon5
ALEToggleFixer	nvim/init.vim	/^command! ALEToggleFixer execute "let g:ale_fix_on_save = get(g:, 'ale_fix_on_save', 0) ? 0 : 1"$/;"	c
BACKGROUND_MASK	nvim/ag/src/print_w32.c	/^#define BACKGROUND_MASK /;"	d	file:
BG_RGB	nvim/ag/src/print_w32.c	/^#define BG_RGB /;"	d	file:
BUF_SIZE	nvim/ag/src/print_w32.c	/^#define BUF_SIZE /;"	d	file:
CASE_DEFAULT	nvim/ag/src/options.h	/^    CASE_DEFAULT, \/* Changes to CASE_SMART at the end of option parsing *\/$/;"	e	enum:case_behavior
CASE_INSENSITIVE	nvim/ag/src/options.h	/^    CASE_INSENSITIVE,$/;"	e	enum:case_behavior
CASE_SENSITIVE	nvim/ag/src/options.h	/^    CASE_SENSITIVE,$/;"	e	enum:case_behavior
CASE_SENSITIVE_RETRY_INSENSITIVE	nvim/ag/src/options.h	/^    CASE_SENSITIVE_RETRY_INSENSITIVE \/* for future use *\/$/;"	e	enum:case_behavior
CASE_SMART	nvim/ag/src/options.h	/^    CASE_SMART,$/;"	e	enum:case_behavior
CAVAIL_IN	nvim/ag/src/zfile.c	/^#define CAVAIL_IN(/;"	d	file:
CHECK_AND_RETURN	nvim/ag/src/util.c	/^#define CHECK_AND_RETURN(/;"	d	file:
CNEXT_OUT	nvim/ag/src/zfile.c	/^#define CNEXT_OUT(/;"	d	file:
DECLTYPE	nvim/ag/src/uthash.h	/^#define DECLTYPE(/;"	d
DECLTYPE_ASSIGN	nvim/ag/src/uthash.h	/^#define DECLTYPE_ASSIGN(/;"	d
DECOMPRESS_H	nvim/ag/src/decompress.h	/^#define DECOMPRESS_H$/;"	d
DEFAULT_AFTER_LEN	nvim/ag/src/options.h	/^#define DEFAULT_AFTER_LEN /;"	d
DEFAULT_BEFORE_LEN	nvim/ag/src/options.h	/^#define DEFAULT_BEFORE_LEN /;"	d
DEFAULT_CONTEXT_LEN	nvim/ag/src/options.h	/^#define DEFAULT_CONTEXT_LEN /;"	d
DEFAULT_MAX_SEARCH_DEPTH	nvim/ag/src/options.h	/^#define DEFAULT_MAX_SEARCH_DEPTH /;"	d
ELMT_FROM_HH	nvim/ag/src/uthash.h	/^#define ELMT_FROM_HH(/;"	d
FALSE	nvim/ag/src/util.h	/^#define FALSE /;"	d
FG_RGB	nvim/ag/src/print_w32.c	/^#define FG_RGB /;"	d	file:
FOREGROUND_MASK	nvim/ag/src/print_w32.c	/^#define FOREGROUND_MASK /;"	d	file:
H	nvim/init.vim	/^command! H let @\/="" " Remove search results$/;"	c
HASH_ADD	nvim/ag/src/uthash.h	/^#define HASH_ADD(/;"	d
HASH_ADD_INT	nvim/ag/src/uthash.h	/^#define HASH_ADD_INT(/;"	d
HASH_ADD_KEYPTR	nvim/ag/src/uthash.h	/^#define HASH_ADD_KEYPTR(/;"	d
HASH_ADD_PTR	nvim/ag/src/uthash.h	/^#define HASH_ADD_PTR(/;"	d
HASH_ADD_STR	nvim/ag/src/uthash.h	/^#define HASH_ADD_STR(/;"	d
HASH_ADD_TO_BKT	nvim/ag/src/uthash.h	/^#define HASH_ADD_TO_BKT(/;"	d
HASH_BER	nvim/ag/src/uthash.h	/^#define HASH_BER(/;"	d
HASH_BKT_CAPACITY_THRESH	nvim/ag/src/uthash.h	/^#define HASH_BKT_CAPACITY_THRESH /;"	d
HASH_BLOOM_ADD	nvim/ag/src/uthash.h	/^#define HASH_BLOOM_ADD(/;"	d
HASH_BLOOM_BITLEN	nvim/ag/src/uthash.h	/^#define HASH_BLOOM_BITLEN /;"	d
HASH_BLOOM_BITSET	nvim/ag/src/uthash.h	/^#define HASH_BLOOM_BITSET(/;"	d
HASH_BLOOM_BITTEST	nvim/ag/src/uthash.h	/^#define HASH_BLOOM_BITTEST(/;"	d
HASH_BLOOM_BYTELEN	nvim/ag/src/uthash.h	/^#define HASH_BLOOM_BYTELEN /;"	d
HASH_BLOOM_FREE	nvim/ag/src/uthash.h	/^#define HASH_BLOOM_FREE(/;"	d
HASH_BLOOM_MAKE	nvim/ag/src/uthash.h	/^#define HASH_BLOOM_MAKE(/;"	d
HASH_BLOOM_SIGNATURE	nvim/ag/src/uthash.h	/^#define HASH_BLOOM_SIGNATURE /;"	d
HASH_BLOOM_TEST	nvim/ag/src/uthash.h	/^#define HASH_BLOOM_TEST(/;"	d
HASH_CLEAR	nvim/ag/src/uthash.h	/^#define HASH_CLEAR(/;"	d
HASH_CNT	nvim/ag/src/uthash.h	/^#define HASH_CNT(/;"	d
HASH_COUNT	nvim/ag/src/uthash.h	/^#define HASH_COUNT(/;"	d
HASH_DEL	nvim/ag/src/uthash.h	/^#define HASH_DEL(/;"	d
HASH_DELETE	nvim/ag/src/uthash.h	/^#define HASH_DELETE(/;"	d
HASH_DEL_IN_BKT	nvim/ag/src/uthash.h	/^#define HASH_DEL_IN_BKT(/;"	d
HASH_EMIT_KEY	nvim/ag/src/uthash.h	/^#define HASH_EMIT_KEY(/;"	d
HASH_EXPAND_BUCKETS	nvim/ag/src/uthash.h	/^#define HASH_EXPAND_BUCKETS(/;"	d
HASH_FCN	nvim/ag/src/uthash.h	/^#define HASH_FCN /;"	d
HASH_FIND	nvim/ag/src/uthash.h	/^#define HASH_FIND(/;"	d
HASH_FIND_INT	nvim/ag/src/uthash.h	/^#define HASH_FIND_INT(/;"	d
HASH_FIND_IN_BKT	nvim/ag/src/uthash.h	/^#define HASH_FIND_IN_BKT(/;"	d
HASH_FIND_PTR	nvim/ag/src/uthash.h	/^#define HASH_FIND_PTR(/;"	d
HASH_FIND_STR	nvim/ag/src/uthash.h	/^#define HASH_FIND_STR(/;"	d
HASH_FNV	nvim/ag/src/uthash.h	/^#define HASH_FNV(/;"	d
HASH_FSCK	nvim/ag/src/uthash.h	/^#define HASH_FSCK(/;"	d
HASH_INITIAL_NUM_BUCKETS	nvim/ag/src/uthash.h	/^#define HASH_INITIAL_NUM_BUCKETS /;"	d
HASH_INITIAL_NUM_BUCKETS_LOG2	nvim/ag/src/uthash.h	/^#define HASH_INITIAL_NUM_BUCKETS_LOG2 /;"	d
HASH_ITER	nvim/ag/src/uthash.h	/^#define HASH_ITER(/;"	d
HASH_JEN	nvim/ag/src/uthash.h	/^#define HASH_JEN(/;"	d
HASH_JEN_MIX	nvim/ag/src/uthash.h	/^#define HASH_JEN_MIX(/;"	d
HASH_KEYCMP	nvim/ag/src/uthash.h	/^#define HASH_KEYCMP(/;"	d
HASH_MAKE_TABLE	nvim/ag/src/uthash.h	/^#define HASH_MAKE_TABLE(/;"	d
HASH_MUR	nvim/ag/src/uthash.h	/^#define HASH_MUR(/;"	d
HASH_OAT	nvim/ag/src/uthash.h	/^#define HASH_OAT(/;"	d
HASH_OOPS	nvim/ag/src/uthash.h	/^#define HASH_OOPS(/;"	d
HASH_OVERHEAD	nvim/ag/src/uthash.h	/^#define HASH_OVERHEAD(/;"	d
HASH_REPLACE	nvim/ag/src/uthash.h	/^#define HASH_REPLACE(/;"	d
HASH_REPLACE_INT	nvim/ag/src/uthash.h	/^#define HASH_REPLACE_INT(/;"	d
HASH_REPLACE_PTR	nvim/ag/src/uthash.h	/^#define HASH_REPLACE_PTR(/;"	d
HASH_REPLACE_STR	nvim/ag/src/uthash.h	/^#define HASH_REPLACE_STR(/;"	d
HASH_SAX	nvim/ag/src/uthash.h	/^#define HASH_SAX(/;"	d
HASH_SELECT	nvim/ag/src/uthash.h	/^#define HASH_SELECT(/;"	d
HASH_SFH	nvim/ag/src/uthash.h	/^#define HASH_SFH(/;"	d
HASH_SIGNATURE	nvim/ag/src/uthash.h	/^#define HASH_SIGNATURE /;"	d
HASH_SORT	nvim/ag/src/uthash.h	/^#define HASH_SORT(/;"	d
HASH_SRT	nvim/ag/src/uthash.h	/^#define HASH_SRT(/;"	d
HASH_TO_BKT	nvim/ag/src/uthash.h	/^#define HASH_TO_BKT(/;"	d
HAVE_LZMA_H	nvim/ag/src/win32/config.h	/^#define HAVE_LZMA_H$/;"	d
HAVE_PTHREAD_H	nvim/ag/src/win32/config.h	/^#define HAVE_PTHREAD_H$/;"	d
H_SIZE	nvim/ag/src/util.h	/^#define H_SIZE /;"	d
IGNORE_H	nvim/ag/src/ignore.h	/^#define IGNORE_H$/;"	d
KB	nvim/ag/src/zfile.c	/^#define KB /;"	d	file:
LANG_H	nvim/ag/src/lang.h	/^#define LANG_H$/;"	d
LOG_H	nvim/ag/src/log.h	/^#define LOG_H$/;"	d
LOG_LEVEL_DEBUG	nvim/ag/src/log.h	/^    LOG_LEVEL_DEBUG = 10,$/;"	e	enum:log_level
LOG_LEVEL_ERR	nvim/ag/src/log.h	/^    LOG_LEVEL_ERR = 40,$/;"	e	enum:log_level
LOG_LEVEL_MSG	nvim/ag/src/log.h	/^    LOG_LEVEL_MSG = 20,$/;"	e	enum:log_level
LOG_LEVEL_NONE	nvim/ag/src/log.h	/^    LOG_LEVEL_NONE = 100$/;"	e	enum:log_level
LOG_LEVEL_WARN	nvim/ag/src/log.h	/^    LOG_LEVEL_WARN = 30,$/;"	e	enum:log_level
LZMA_HEADER_SOMETIMES	nvim/ag/src/decompress.c	/^const uint8_t LZMA_HEADER_SOMETIMES[3] = { 0x5D, 0x00, 0x00 };$/;"	v
LightlineFugitive	nvim/init.vim	/^function! LightlineFugitive()$/;"	f
LightlineModified	nvim/init.vim	/^function! LightlineModified()$/;"	f
LightlineReadonly	nvim/init.vim	/^function! LightlineReadonly()$/;"	f
MAX_EXTENSIONS	nvim/ag/src/lang.h	/^#define MAX_EXTENSIONS /;"	d
MAX_VALUES	nvim/ag/src/print_w32.c	/^#define MAX_VALUES /;"	d	file:
MUR_FMIX	nvim/ag/src/uthash.h	/^#define MUR_FMIX(/;"	d
MUR_GETBLOCK	nvim/ag/src/uthash.h	/^#define MUR_GETBLOCK(/;"	d
MUR_ONE_THREE	nvim/ag/src/uthash.h	/^#define MUR_ONE_THREE(/;"	d
MUR_PLUS0_ALIGNED	nvim/ag/src/uthash.h	/^#define MUR_PLUS0_ALIGNED(/;"	d
MUR_PLUS1_ALIGNED	nvim/ag/src/uthash.h	/^#define MUR_PLUS1_ALIGNED(/;"	d
MUR_PLUS2_ALIGNED	nvim/ag/src/uthash.h	/^#define MUR_PLUS2_ALIGNED(/;"	d
MUR_PLUS3_ALIGNED	nvim/ag/src/uthash.h	/^#define MUR_PLUS3_ALIGNED(/;"	d
MUR_ROTL32	nvim/ag/src/uthash.h	/^#define MUR_ROTL32(/;"	d
MUR_THREE_ONE	nvim/ag/src/uthash.h	/^#define MUR_THREE_ONE(/;"	d
MUR_TWO_TWO	nvim/ag/src/uthash.h	/^#define MUR_TWO_TWO(/;"	d
NERDTreeShowHidden	nvim/init.vim	/^let NERDTreeShowHidden=1$/;"	v
NO_DECLTYPE	nvim/ag/src/uthash.h	/^#define NO_DECLTYPE$/;"	d
NO_SANITIZE_ALIGNMENT	nvim/ag/src/util.h	/^#define NO_SANITIZE_ALIGNMENT /;"	d
NO_SANITIZE_ALIGNMENT	nvim/ag/src/util.h	/^#define NO_SANITIZE_ALIGNMENT$/;"	d
OPTIONS_H	nvim/ag/src/options.h	/^#define OPTIONS_H$/;"	d
PATH_PRINT_DEFAULT	nvim/ag/src/options.h	/^    PATH_PRINT_DEFAULT,           \/* PRINT_TOP if > 1 file being searched, else PRINT_NOTHING *\/$/;"	e	enum:path_print_behavior
PATH_PRINT_DEFAULT_EACH_LINE	nvim/ag/src/options.h	/^    PATH_PRINT_DEFAULT_EACH_LINE, \/* PRINT_EACH_LINE if > 1 file being searched, else PRINT_NOTHING *\/$/;"	e	enum:path_print_behavior
PATH_PRINT_EACH_LINE	nvim/ag/src/options.h	/^    PATH_PRINT_EACH_LINE,$/;"	e	enum:path_print_behavior
PATH_PRINT_NOTHING	nvim/ag/src/options.h	/^    PATH_PRINT_NOTHING$/;"	e	enum:path_print_behavior
PATH_PRINT_TOP	nvim/ag/src/options.h	/^    PATH_PRINT_TOP,$/;"	e	enum:path_print_behavior
PRINT_H	nvim/ag/src/print.h	/^#define PRINT_H$/;"	d
SCANDIR_H	nvim/ag/src/scandir.h	/^#define SCANDIR_H$/;"	d
SEARCH_H	nvim/ag/src/search.h	/^#define SEARCH_H$/;"	d
SINGLE_EXT_LEN	nvim/ag/src/lang.h	/^#define SINGLE_EXT_LEN /;"	d
SYMLOOP_ERROR	nvim/ag/src/search.h	/^#define SYMLOOP_ERROR /;"	d
SYMLOOP_LOOP	nvim/ag/src/search.h	/^#define SYMLOOP_LOOP /;"	d
SYMLOOP_OK	nvim/ag/src/search.h	/^#define SYMLOOP_OK /;"	d
TRUE	nvim/ag/src/util.h	/^#define TRUE /;"	d
UTHASH_H	nvim/ag/src/uthash.h	/^#define UTHASH_H$/;"	d
UTHASH_VERSION	nvim/ag/src/uthash.h	/^#define UTHASH_VERSION /;"	d
UTIL_H	nvim/ag/src/util.h	/^#define UTIL_H$/;"	d
UT_hash_bucket	nvim/ag/src/uthash.h	/^typedef struct UT_hash_bucket {$/;"	s
UT_hash_bucket	nvim/ag/src/uthash.h	/^} UT_hash_bucket;$/;"	t	typeref:struct:UT_hash_bucket
UT_hash_handle	nvim/ag/src/uthash.h	/^typedef struct UT_hash_handle {$/;"	s
UT_hash_handle	nvim/ag/src/uthash.h	/^} UT_hash_handle;$/;"	t	typeref:struct:UT_hash_handle
UT_hash_table	nvim/ag/src/uthash.h	/^typedef struct UT_hash_table {$/;"	s
UT_hash_table	nvim/ag/src/uthash.h	/^} UT_hash_table;$/;"	t	typeref:struct:UT_hash_table
WP	nvim/ag/src/uthash.h	/^#define WP(/;"	d
XZ_HEADER_MAGIC	nvim/ag/src/decompress.c	/^const uint8_t XZ_HEADER_MAGIC[6] = { 0xFD, '7', 'z', 'X', 'Z', 0x00 };$/;"	v
ZLIB_CONST	nvim/ag/src/decompress.c	/^#define ZLIB_CONST /;"	d	file:
_ag	nvim/ag/ag.bashcomp.sh	/^_ag() {$/;"	f
abs_path	nvim/ag/src/ignore.h	/^    char *abs_path;$/;"	m	struct:ignores
abs_path_len	nvim/ag/src/ignore.h	/^    size_t abs_path_len;$/;"	m	struct:ignores
ackmate	nvim/ag/src/options.h	/^    int ackmate;$/;"	m	struct:__anon2
ackmate_dir_filter	nvim/ag/src/options.h	/^    pcre *ackmate_dir_filter;$/;"	m	struct:__anon2
ackmate_dir_filter_extra	nvim/ag/src/options.h	/^    pcre_extra *ackmate_dir_filter_extra;$/;"	m	struct:__anon2
ackmate_dir_match	nvim/ag/src/ignore.c	/^static int ackmate_dir_match(const char *dir_name) {$/;"	f	file:
actual_len	nvim/ag/src/zfile.c	/^        actual_len;$/;"	m	struct:zfile	file:
add_ignore_pattern	nvim/ag/src/ignore.c	/^void add_ignore_pattern(ignores *ig, const char *pattern) {$/;"	f
after	nvim/ag/src/options.h	/^    size_t after;$/;"	m	struct:__anon2
ag_asprintf	nvim/ag/src/util.c	/^void ag_asprintf(char **ret, const char *fmt, ...) {$/;"	f
ag_calloc	nvim/ag/src/util.c	/^void *ag_calloc(size_t count, size_t size) {$/;"	f
ag_compression_type	nvim/ag/src/decompress.h	/^} ag_compression_type;$/;"	t	typeref:enum:__anon5
ag_malloc	nvim/ag/src/util.c	/^void *ag_malloc(size_t size) {$/;"	f
ag_max	nvim/ag/src/util.c	/^size_t ag_max(size_t a, size_t b) {$/;"	f
ag_min	nvim/ag/src/util.c	/^size_t ag_min(size_t a, size_t b) {$/;"	f
ag_realloc	nvim/ag/src/util.c	/^void *ag_realloc(void *ptr, size_t size) {$/;"	f
ag_scandir	nvim/ag/src/scandir.c	/^int ag_scandir(const char *dirname,$/;"	f
ag_stats	nvim/ag/src/util.h	/^} ag_stats;$/;"	t	typeref:struct:__anon7
ag_strdup	nvim/ag/src/util.c	/^char *ag_strdup(const char *s) {$/;"	f
ag_strndup	nvim/ag/src/util.c	/^char *ag_strndup(const char *s, size_t size) {$/;"	f
alpha_skip_lookup	nvim/ag/src/search.c	/^size_t alpha_skip_lookup[256];$/;"	v
as_chars	nvim/ag/src/util.h	/^    char as_chars[sizeof(uint16_t)];$/;"	m	union:__anon8
as_word	nvim/ag/src/util.h	/^    uint16_t as_word;$/;"	m	union:__anon8
base_path	nvim/ag/src/scandir.h	/^    const char *base_path;$/;"	m	struct:__anon9
base_path_len	nvim/ag/src/scandir.h	/^    size_t base_path_len;$/;"	m	struct:__anon9
before	nvim/ag/src/options.h	/^    size_t before;$/;"	m	struct:__anon2
big_file	nvim/ag/tests/big/create_big_file.py	/^big_file = sys.argv[1]$/;"	v
binary_search	nvim/ag/src/util.c	/^int binary_search(const char *needle, char **haystack, int start, int end) {$/;"	f
bloom_bv	nvim/ag/src/uthash.h	/^    uint8_t *bloom_bv;$/;"	m	struct:UT_hash_table
bloom_nbits	nvim/ag/src/uthash.h	/^    char bloom_nbits;$/;"	m	struct:UT_hash_table
bloom_sig	nvim/ag/src/uthash.h	/^    uint32_t bloom_sig; \/* used only to test bloom exists in external analysis *\/$/;"	m	struct:UT_hash_table
boyer_moore_strnstr	nvim/ag/src/util.c	/^const char *boyer_moore_strnstr(const char *s, const char *find, const size_t s_len, const size_t f_len,$/;"	f
buckets	nvim/ag/src/uthash.h	/^    UT_hash_bucket *buckets;$/;"	m	struct:UT_hash_table
buf_getline	nvim/ag/src/util.c	/^ssize_t buf_getline(const char **line, const char *buf, const size_t buf_len, const size_t buf_offset) {$/;"	f
case_behavior	nvim/ag/src/options.h	/^enum case_behavior {$/;"	g
casing	nvim/ag/src/options.h	/^    enum case_behavior casing;$/;"	m	struct:__anon2	typeref:enum:__anon2::case_behavior
check_symloop_enter	nvim/ag/src/search.c	/^static int check_symloop_enter(const char *path, dirkey_t *outkey) {$/;"	f	file:
check_symloop_leave	nvim/ag/src/search.c	/^static int check_symloop_leave(dirkey_t *dirkey) {$/;"	f	file:
cleanup_ignore	nvim/ag/src/ignore.c	/^void cleanup_ignore(ignores *ig) {$/;"	f
cleanup_options	nvim/ag/src/options.c	/^void cleanup_options(void) {$/;"	f
cli_options	nvim/ag/src/options.h	/^} cli_options;$/;"	t	typeref:struct:__anon2
cn	nvim/init.vim	/^nmap cn :cn<cr>$/;"	m
color	nvim/ag/src/options.h	/^    int color;$/;"	m	struct:__anon2
color_line_number	nvim/ag/src/options.c	/^const char *color_line_number = "\\033[1;33m"; \/* bold yellow *\/$/;"	v
color_line_number	nvim/ag/src/options.h	/^    char *color_line_number;$/;"	m	struct:__anon2
color_match	nvim/ag/src/options.c	/^const char *color_match = "\\033[30;43m";      \/* black with yellow background *\/$/;"	v
color_match	nvim/ag/src/options.h	/^    char *color_match;$/;"	m	struct:__anon2
color_path	nvim/ag/src/options.c	/^const char *color_path = "\\033[1;32m";        \/* bold green *\/$/;"	v
color_path	nvim/ag/src/options.h	/^    char *color_path;$/;"	m	struct:__anon2
color_reset	nvim/ag/src/print.c	/^const char *color_reset = "\\033[0m\\033[K";$/;"	v
color_win_ansi	nvim/ag/src/options.h	/^    int color_win_ansi;$/;"	m	struct:__anon2
column	nvim/ag/src/options.h	/^    int column;$/;"	m	struct:__anon2
combine_file_extensions	nvim/ag/src/lang.c	/^size_t combine_file_extensions(size_t *extension_index, size_t len, char **exts) {$/;"	f
compile_study	nvim/ag/src/util.c	/^void compile_study(pcre **re, pcre_extra **re_extra, char *q, const int pcre_opts, const int study_opts) {$/;"	f
context	nvim/ag/src/options.h	/^    int context;$/;"	m	struct:__anon2
context_prev_lines	nvim/ag/src/print.c	/^    char **context_prev_lines;$/;"	m	struct:print_context	file:
count	nvim/ag/src/uthash.h	/^    unsigned count;$/;"	m	struct:UT_hash_bucket
create_big_file	nvim/ag/tests/big/create_big_file.py	/^def create_big_file():$/;"	f
ctype	nvim/ag/src/zfile.c	/^    ag_compression_type ctype;$/;"	m	struct:zfile	file:
decode_offset	nvim/ag/src/zfile.c	/^        decode_offset,     \/\/ Where we've decoded to$/;"	m	struct:zfile	file:
decompress	nvim/ag/src/decompress.c	/^void *decompress(const ag_compression_type zip_type, const void *buf, const int buf_len,$/;"	f
decompress_lzma	nvim/ag/src/decompress.c	/^static void *decompress_lzma(const void *buf, const int buf_len,$/;"	f	file:
decompress_lzw	nvim/ag/src/decompress.c	/^static void *decompress_lzw(const void *buf, const int buf_len,$/;"	f	file:
decompress_open	nvim/ag/src/zfile.c	/^decompress_open(int fd, const char *mode, ag_compression_type ctype) {$/;"	f
decompress_zip	nvim/ag/src/decompress.c	/^static void *decompress_zip(const void *buf, const int buf_len,$/;"	f	file:
decompress_zlib	nvim/ag/src/decompress.c	/^static void *decompress_zlib(const void *buf, const int buf_len,$/;"	f	file:
dev	nvim/ag/src/search.h	/^    dev_t dev;$/;"	m	struct:__anon10
die	nvim/ag/sanitize.sh	/^die() {$/;"	f
die	nvim/ag/src/util.c	/^void die(const char *fmt, ...) {$/;"	f
dirkey_t	nvim/ag/src/search.h	/^} dirkey_t;$/;"	t	typeref:struct:__anon10
dirname	nvim/ag/src/ignore.h	/^    const char *dirname;$/;"	m	struct:ignores
dirname_len	nvim/ag/src/ignore.h	/^    size_t dirname_len;$/;"	m	struct:ignores
done_adding_files	nvim/ag/src/search.c	/^int done_adding_files = 0;$/;"	v
end	nvim/ag/src/util.h	/^    size_t end;   \/* and where it ends *\/$/;"	m	struct:__anon6
eof	nvim/ag/src/zfile.c	/^    bool eof;$/;"	m	struct:zfile	file:
evil_hardcoded_ignore_files	nvim/ag/src/ignore.c	/^const char *evil_hardcoded_ignore_files[] = {$/;"	v
expand_mult	nvim/ag/src/uthash.h	/^    unsigned expand_mult;$/;"	m	struct:UT_hash_bucket
extensions	nvim/ag/src/ignore.h	/^    char **extensions; \/* File extensions to ignore *\/$/;"	m	struct:ignores
extensions	nvim/ag/src/lang.h	/^    const char *extensions[MAX_EXTENSIONS];$/;"	m	struct:__anon3
extensions_len	nvim/ag/src/ignore.h	/^    size_t extensions_len;$/;"	m	struct:ignores
fd	nvim/ag/tests/big/create_big_file.py	/^    fd = open(big_file, "r")$/;"	v
fgetln	nvim/ag/src/util.c	/^char *fgetln(FILE *fp, size_t *lenp) {$/;"	f
file_search_regex	nvim/ag/src/options.h	/^    pcre *file_search_regex;$/;"	m	struct:__anon2
file_search_regex_extra	nvim/ag/src/options.h	/^    pcre_extra *file_search_regex_extra;$/;"	m	struct:__anon2
file_search_string	nvim/ag/src/options.h	/^    const char *file_search_string;$/;"	m	struct:__anon2
filename_filter	nvim/ag/src/ignore.c	/^int filename_filter(const char *path, const struct dirent *dir, void *baton) {$/;"	f
files_ready	nvim/ag/src/search.c	/^pthread_cond_t files_ready = PTHREAD_COND_INITIALIZER;$/;"	v
filter_fp	nvim/ag/src/scandir.h	/^typedef int (*filter_fp)(const char *path, const struct dirent *, void *);$/;"	t
find_skip_lookup	nvim/ag/src/search.c	/^size_t *find_skip_lookup;$/;"	v
first_file_match	nvim/ag/src/print.c	/^int first_file_match = 1;$/;"	v
flockfile	nvim/ag/src/util.c	/^#define flockfile(/;"	d	file:
fnmatch	nvim/ag/src/ignore.c	/^#define fnmatch(/;"	d	file:
fnmatch_flags	nvim/ag/src/ignore.c	/^const int fnmatch_flags = FNM_PATHNAME;$/;"	v
follow_symlinks	nvim/ag/src/options.h	/^    int follow_symlinks;$/;"	m	struct:__anon2
fprintf	nvim/ag/src/print.c	/^#define fprintf(/;"	d	file:
fprintf_w32	nvim/ag/src/print_w32.c	/^int fprintf_w32(FILE *fp, const char *format, ...) {$/;"	f
free_strings	nvim/ag/src/util.c	/^void free_strings(char **strs, const size_t strs_len) {$/;"	f
funlockfile	nvim/ag/src/util.c	/^#define funlockfile(/;"	d	file:
g:EasyMotion_leader_key	nvim/init.vim	/^let g:EasyMotion_leader_key = '<Leader>'$/;"	v
g:UltiSnipsEditSplit	nvim/init.vim	/^let g:UltiSnipsEditSplit="vertical"$/;"	v
g:UltiSnipsExpandTrigger	nvim/init.vim	/^let g:UltiSnipsExpandTrigger="<tab>"$/;"	v
g:UltiSnipsJumpBackwardTrigger	nvim/init.vim	/^let g:UltiSnipsJumpBackwardTrigger="<c-z>"$/;"	v
g:UltiSnipsJumpForwardTrigger	nvim/init.vim	/^    let g:UltiSnipsJumpForwardTrigger = "<tab>"$/;"	v
g:UltiSnipsJumpForwardTrigger	nvim/init.vim	/^let g:UltiSnipsJumpForwardTrigger="<c-b>"$/;"	v
g:UltiSnipsSnippetDirectories	nvim/init.vim	/^let g:UltiSnipsSnippetDirectories = ['~\/.vim\/UltiSnips', 'UltiSnips']$/;"	v
g:ale_echo_msg_format	nvim/init.vim	/^let g:ale_echo_msg_format = '%linter%: %s'$/;"	v
g:ale_fix_on_save	nvim/init.vim	/^let g:ale_fix_on_save = 1$/;"	v
g:ale_fixers	nvim/init.vim	/^let g:ale_fixers = {$/;"	v
g:ale_linters	nvim/init.vim	/^let g:ale_linters = {$/;"	v
g:ale_linters_explicit	nvim/init.vim	/^let g:ale_linters_explicit = 1$/;"	v
g:ale_set_balloons	nvim/init.vim	/^let g:ale_set_balloons = 1$/;"	v
g:ale_set_highlights	nvim/init.vim	/^let g:ale_set_highlights = 0$/;"	v
g:ale_sign_column_always	nvim/init.vim	/^let g:ale_sign_column_always = 1$/;"	v
g:colors_name	nvim/colors/monokai.vim	/^let g:colors_name = "monokai"$/;"	v
g:gitgutter_max_signs	nvim/init.vim	/^let g:gitgutter_max_signs = 2000$/;"	v
g:jsx_ext_required	nvim/init.vim	/^let g:jsx_ext_required = 0$/;"	v
g:lightline	nvim/init.vim	/^let g:lightline = {$/;"	v
g:mapleader	nvim/init.vim	/^let g:mapleader = ","$/;"	v
g:python3_host_prog	nvim/init.vim	/^let g:python3_host_prog = '\/usr\/bin\/python3'$/;"	v
g:ragtag_global_maps	nvim/init.vim	/^let g:ragtag_global_maps = 1$/;"	v
g:rainbow_active	nvim/init.vim	/^let g:rainbow_active = 1$/;"	v
g:syntastic_aggregate_errors	nvim/init.vim	/^let g:syntastic_aggregate_errors = 1$/;"	v
g:syntastic_always_populate_loc_list	nvim/init.vim	/^let g:syntastic_always_populate_loc_list = 1$/;"	v
g:syntastic_auto_loc_list	nvim/init.vim	/^let g:syntastic_auto_loc_list = 2$/;"	v
g:syntastic_check_on_open	nvim/init.vim	/^let g:syntastic_check_on_open = 1$/;"	v
g:syntastic_check_on_wq	nvim/init.vim	/^let g:syntastic_check_on_wq = 0$/;"	v
g:syntastic_html_checkers	nvim/init.vim	/^let g:syntastic_html_checkers=['']$/;"	v
g:syntastic_javascript_checkers	nvim/init.vim	/^let g:syntastic_javascript_checkers = ['eslint']$/;"	v
g:syntastic_javascript_eslint_exec	nvim/init.vim	/^let g:syntastic_javascript_eslint_exec = '.\/node_modules\/.bin\/eslint'$/;"	v
g:vim_markdown_folding_disabled	nvim/init.vim	/^let g:vim_markdown_folding_disabled = 1 "markdown folding$/;"	v
g_use_ansi	nvim/ag/src/print_w32.c	/^static int g_use_ansi = 0;$/;"	v	file:
generate_alpha_skip	nvim/ag/src/util.c	/^void generate_alpha_skip(const char *find, size_t f_len, size_t skip_lookup[], const int case_sensitive) {$/;"	f
generate_find_skip	nvim/ag/src/util.c	/^void generate_find_skip(const char *find, const size_t f_len, size_t **skip_lookup, const int case_sensitive) {$/;"	f
generate_hash	nvim/ag/src/util.c	/^void generate_hash(const char *find, const size_t f_len, uint8_t *h_table, const int case_sensitive) {$/;"	f
get16bits	nvim/ag/src/uthash.h	/^#define get16bits(/;"	d
get16bits	nvim/ag/src/uthash.h	/^#undef get16bits$/;"	d
get_lang_count	nvim/ag/src/lang.c	/^size_t get_lang_count() {$/;"	f
getc_unlocked	nvim/ag/src/util.c	/^#define getc_unlocked(/;"	d	file:
getline	nvim/ag/src/util.c	/^ssize_t getline(char **lineptr, size_t *n, FILE *stream) {$/;"	f
gz	nvim/ag/src/zfile.c	/^        z_stream gz;$/;"	m	union:zfile::__anon1	file:
h_table	nvim/ag/src/search.c	/^uint8_t h_table[H_SIZE] __attribute__((aligned(64)));$/;"	v
hash_strnstr	nvim/ag/src/util.c	/^NO_SANITIZE_ALIGNMENT const char *hash_strnstr(const char *s, const char *find, const size_t s_len, const size_t f_len, uint8_t *h_table, const int case_sensitive) {$/;"	f
hashv	nvim/ag/src/uthash.h	/^    unsigned hashv;                 \/* result of hash-fcn(key)        *\/$/;"	m	struct:UT_hash_handle
hh	nvim/ag/src/search.h	/^    UT_hash_handle hh;$/;"	m	struct:__anon11
hh_head	nvim/ag/src/uthash.h	/^    struct UT_hash_handle *hh_head;$/;"	m	struct:UT_hash_bucket	typeref:struct:UT_hash_bucket::UT_hash_handle
hh_next	nvim/ag/src/uthash.h	/^    struct UT_hash_handle *hh_next; \/* next hh in bucket order        *\/$/;"	m	struct:UT_hash_handle	typeref:struct:UT_hash_handle::UT_hash_handle
hh_prev	nvim/ag/src/uthash.h	/^    struct UT_hash_handle *hh_prev; \/* previous hh in bucket order    *\/$/;"	m	struct:UT_hash_handle	typeref:struct:UT_hash_handle::UT_hash_handle
hho	nvim/ag/src/uthash.h	/^    ptrdiff_t hho;               \/* hash handle offset (byte pos of hash handle in element *\/$/;"	m	struct:UT_hash_table
id	nvim/ag/src/main.c	/^    int id;$/;"	m	struct:__anon4	file:
ideal_chain_maxlen	nvim/ag/src/uthash.h	/^    unsigned ideal_chain_maxlen;$/;"	m	struct:UT_hash_table
ig	nvim/ag/src/scandir.h	/^    const ignores *ig;$/;"	m	struct:__anon9
ignore_pattern_files	nvim/ag/src/ignore.c	/^const char *ignore_pattern_files[] = {$/;"	v
ignores	nvim/ag/src/ignore.h	/^struct ignores {$/;"	s
ignores	nvim/ag/src/ignore.h	/^typedef struct ignores ignores;$/;"	t	typeref:struct:ignores
in	nvim/ag/src/zfile.c	/^    FILE *in;              \/\/ Source FILE stream$/;"	m	struct:zfile	file:
in_a_match	nvim/ag/src/print.c	/^    int in_a_match;$/;"	m	struct:print_context	file:
inbuf	nvim/ag/src/zfile.c	/^    uint8_t inbuf[32 * KB];$/;"	m	struct:zfile	file:
ineff_expands	nvim/ag/src/uthash.h	/^    unsigned ineff_expands, noexpand;$/;"	m	struct:UT_hash_table
init_ignore	nvim/ag/src/ignore.c	/^ignores *init_ignore(ignores *parent, const char *dirname, const size_t dirname_len) {$/;"	f
init_options	nvim/ag/src/options.c	/^void init_options(void) {$/;"	f
init_wordchar_table	nvim/ag/src/util.c	/^void init_wordchar_table(void) {$/;"	f
ino	nvim/ag/src/search.h	/^    ino_t ino;$/;"	m	struct:__anon10
invert_match	nvim/ag/src/options.h	/^    int invert_match;$/;"	m	struct:__anon2
invert_matches	nvim/ag/src/util.c	/^size_t invert_matches(const char *buf, const size_t buf_len, match_t matches[], size_t matches_len) {$/;"	f
invert_regexes	nvim/ag/src/ignore.h	/^    char **invert_regexes; \/* For "!" patterns *\/$/;"	m	struct:ignores
invert_regexes_len	nvim/ag/src/ignore.h	/^    size_t invert_regexes_len;$/;"	m	struct:ignores
is_binary	nvim/ag/src/util.c	/^int is_binary(const void *buf, const size_t buf_len) {$/;"	f
is_directory	nvim/ag/src/util.c	/^int is_directory(const char *path, const struct dirent *d) {$/;"	f
is_empty	nvim/ag/src/ignore.c	/^int is_empty(ignores *ig) {$/;"	f
is_fnmatch	nvim/ag/src/util.c	/^int is_fnmatch(const char *filename) {$/;"	f
is_lowercase	nvim/ag/src/util.c	/^int is_lowercase(const char *s) {$/;"	f
is_named_pipe	nvim/ag/src/util.c	/^int is_named_pipe(const char *path, const struct dirent *d) {$/;"	f
is_prefix	nvim/ag/src/util.c	/^int is_prefix(const char *s, const size_t s_len, const size_t pos, const int case_sensitive) {$/;"	f
is_regex	nvim/ag/src/util.c	/^int is_regex(const char *query) {$/;"	f
is_symlink	nvim/ag/src/util.c	/^int is_symlink(const char *path, const struct dirent *d) {$/;"	f
is_wordchar	nvim/ag/src/util.c	/^int is_wordchar(char ch) {$/;"	f
is_zipped	nvim/ag/src/decompress.c	/^ag_compression_type is_zipped(const void *buf, const int buf_len) {$/;"	f
j	nvim/init.vim	/^nnoremap j gj$/;"	m
jj	nvim/init.vim	/^imap jj <esc>$/;"	m
k	nvim/init.vim	/^nnoremap k gk$/;"	m
key	nvim/ag/src/search.h	/^    dirkey_t key;$/;"	m	struct:__anon11
key	nvim/ag/src/uthash.h	/^    void *key;                      \/* ptr to enclosing struct's key  *\/$/;"	m	struct:UT_hash_handle
keylen	nvim/ag/src/uthash.h	/^    unsigned keylen;                \/* enclosing struct's key len     *\/$/;"	m	struct:UT_hash_handle
lang_spec_t	nvim/ag/src/lang.h	/^} lang_spec_t;$/;"	t	typeref:struct:__anon3
langs	nvim/ag/src/lang.c	/^lang_spec_t langs[] = {$/;"	v
last_prev_line	nvim/ag/src/print.c	/^    size_t last_prev_line;$/;"	m	struct:print_context	file:
last_printed_match	nvim/ag/src/print.c	/^    size_t last_printed_match;$/;"	m	struct:print_context	file:
line	nvim/ag/src/print.c	/^    size_t line;$/;"	m	struct:print_context	file:
line_preceding_current_match_offset	nvim/ag/src/print.c	/^    size_t line_preceding_current_match_offset;$/;"	m	struct:print_context	file:
lines_since_last_match	nvim/ag/src/print.c	/^    size_t lines_since_last_match;$/;"	m	struct:print_context	file:
literal	nvim/ag/src/options.h	/^    int literal;$/;"	m	struct:__anon2
literal_ends_wordchar	nvim/ag/src/options.h	/^    int literal_ends_wordchar;$/;"	m	struct:__anon2
literal_starts_wordchar	nvim/ag/src/options.h	/^    int literal_starts_wordchar;$/;"	m	struct:__anon2
load_ignore_patterns	nvim/ag/src/ignore.c	/^void load_ignore_patterns(ignores *ig, const char *path) {$/;"	f
log2_num_buckets	nvim/ag/src/uthash.h	/^    unsigned num_buckets, log2_num_buckets;$/;"	m	struct:UT_hash_table
log_debug	nvim/ag/src/log.c	/^void log_debug(const char *fmt, ...) {$/;"	f
log_err	nvim/ag/src/log.c	/^void log_err(const char *fmt, ...) {$/;"	f
log_level	nvim/ag/src/log.h	/^enum log_level {$/;"	g
log_msg	nvim/ag/src/log.c	/^void log_msg(const char *fmt, ...) {$/;"	f
log_threshold	nvim/ag/src/log.c	/^static enum log_level log_threshold = LOG_LEVEL_ERR;$/;"	v	typeref:enum:log_level	file:
log_warn	nvim/ag/src/log.c	/^void log_warn(const char *fmt, ...) {$/;"	f
logic_offset	nvim/ag/src/zfile.c	/^    uint64_t logic_offset, \/\/ Logical offset in output (forward seeks)$/;"	m	struct:zfile	file:
lzma	nvim/ag/src/zfile.c	/^        lzma_stream lzma;$/;"	m	union:zfile::__anon1	file:
main	nvim/ag/src/main.c	/^int main(int argc, char **argv) {$/;"	f
make_lang_regex	nvim/ag/src/lang.c	/^char *make_lang_regex(char *ext_array, size_t num_exts) {$/;"	f
mapleader	nvim/init.vim	/^let mapleader = ","$/;"	v
match_files	nvim/ag/src/options.h	/^    int match_files;$/;"	m	struct:__anon2
match_found	nvim/ag/src/options.h	/^    int match_found;        \/* This should totally not be in here *\/$/;"	m	struct:__anon2
match_t	nvim/ag/src/util.h	/^} match_t;$/;"	t	typeref:struct:__anon6
max_matches_per_file	nvim/ag/src/options.h	/^    size_t max_matches_per_file;$/;"	m	struct:__anon2
max_search_depth	nvim/ag/src/options.h	/^    int max_search_depth;$/;"	m	struct:__anon2
min	nvim/ag/src/zfile.c	/^#define min(/;"	d	file:
mmap	nvim/ag/src/options.h	/^    int mmap;$/;"	m	struct:__anon2
multiline	nvim/ag/src/options.h	/^    int multiline;$/;"	m	struct:__anon2
name	nvim/ag/src/lang.h	/^    const char *name;$/;"	m	struct:__anon3
names	nvim/ag/src/ignore.h	/^    char **names; \/* Non-regex ignore lines. Sorted so we can binary search them. *\/$/;"	m	struct:ignores
names_len	nvim/ag/src/ignore.h	/^    size_t names_len;$/;"	m	struct:ignores
next	nvim/ag/src/search.h	/^    struct work_queue_t *next;$/;"	m	struct:work_queue_t	typeref:struct:work_queue_t::work_queue_t
next	nvim/ag/src/uthash.h	/^    void *next;                     \/* next element in app order      *\/$/;"	m	struct:UT_hash_handle
noexpand	nvim/ag/src/uthash.h	/^    unsigned ineff_expands, noexpand;$/;"	m	struct:UT_hash_table
nonideal_items	nvim/ag/src/uthash.h	/^    unsigned nonideal_items;$/;"	m	struct:UT_hash_table
normalize_path	nvim/ag/src/print.c	/^const char *normalize_path(const char *path) {$/;"	f
num_buckets	nvim/ag/src/uthash.h	/^    unsigned num_buckets, log2_num_buckets;$/;"	m	struct:UT_hash_table
num_items	nvim/ag/src/uthash.h	/^    unsigned num_items;$/;"	m	struct:UT_hash_table
off64_t	nvim/ag/src/zfile.c	/^typedef _off64_t off64_t;$/;"	t	file:
one_dev	nvim/ag/src/options.h	/^    int one_dev;$/;"	m	struct:__anon2
only_matching	nvim/ag/src/options.h	/^    int only_matching;$/;"	m	struct:__anon2
option_t	nvim/ag/src/options.h	/^typedef struct option option_t;$/;"	t	typeref:struct:option
opts	nvim/ag/src/options.c	/^cli_options opts;$/;"	v
out_fd	nvim/ag/src/util.c	/^FILE *out_fd = NULL;$/;"	v
outbuf	nvim/ag/src/zfile.c	/^    uint8_t outbuf[256 * KB];$/;"	m	struct:zfile	file:
outbuf_start	nvim/ag/src/zfile.c	/^    uint32_t outbuf_start;$/;"	m	struct:zfile	file:
pager	nvim/ag/src/options.h	/^    char *pager;$/;"	m	struct:__anon2
parallel	nvim/ag/src/options.h	/^    int parallel;$/;"	m	struct:__anon2
parent	nvim/ag/src/ignore.h	/^    struct ignores *parent;$/;"	m	struct:ignores	typeref:struct:ignores::ignores
parse_options	nvim/ag/src/options.c	/^void parse_options(int argc, char **argv, char **base_paths[], char **paths[]) {$/;"	f
passthrough	nvim/ag/src/options.h	/^    int passthrough;$/;"	m	struct:__anon2
path	nvim/ag/src/search.h	/^    char *path;$/;"	m	struct:work_queue_t
path_ignore_search	nvim/ag/src/ignore.c	/^static int path_ignore_search(const ignores *ig, const char *path, const char *filename) {$/;"	f	file:
path_print_behavior	nvim/ag/src/options.h	/^enum path_print_behavior {$/;"	g
path_sep	nvim/ag/src/options.h	/^    char path_sep;$/;"	m	struct:__anon2
path_start	nvim/ag/src/scandir.h	/^    const char *path_start;$/;"	m	struct:__anon9
path_to_ignore	nvim/ag/src/options.h	/^    int path_to_ignore;$/;"	m	struct:__anon2
paths_len	nvim/ag/src/options.h	/^    int paths_len;$/;"	m	struct:__anon2
plog	nvim/ag/src/log.c	/^void plog(const unsigned int level, const char *fmt, ...) {$/;"	f
prev	nvim/ag/src/uthash.h	/^    void *prev;                     \/* prev element in app order      *\/$/;"	m	struct:UT_hash_handle
prev_line	nvim/ag/src/print.c	/^    size_t prev_line;$/;"	m	struct:print_context	file:
prev_line_offset	nvim/ag/src/print.c	/^    size_t prev_line_offset;$/;"	m	struct:print_context	file:
print_all_paths	nvim/ag/src/options.h	/^    int print_all_paths;$/;"	m	struct:__anon2
print_binary_file_matches	nvim/ag/src/print.c	/^void print_binary_file_matches(const char *path) {$/;"	f
print_break	nvim/ag/src/options.h	/^    int print_break;$/;"	m	struct:__anon2
print_cleanup_context	nvim/ag/src/print.c	/^void print_cleanup_context(void) {$/;"	f
print_column_number	nvim/ag/src/print.c	/^void print_column_number(const match_t matches[], size_t last_printed_match,$/;"	f
print_context	nvim/ag/src/print.c	/^__thread struct print_context {$/;"	s	file:
print_context	nvim/ag/src/print.c	/^} print_context;$/;"	v	typeref:struct:print_context
print_context_append	nvim/ag/src/print.c	/^void print_context_append(const char *line, size_t len) {$/;"	f
print_count	nvim/ag/src/options.h	/^    int print_count;$/;"	m	struct:__anon2
print_file_matches	nvim/ag/src/print.c	/^void print_file_matches(const char *path, const char *buf, const size_t buf_len, const match_t matches[], const size_t matches_len) {$/;"	f
print_file_separator	nvim/ag/src/print.c	/^void print_file_separator(void) {$/;"	f
print_filename_only	nvim/ag/src/options.h	/^    int print_filename_only;$/;"	m	struct:__anon2
print_init_context	nvim/ag/src/print.c	/^void print_init_context(void) {$/;"	f
print_line	nvim/ag/src/print.c	/^void print_line(const char *buf, size_t buf_pos, size_t prev_line_offset) {$/;"	f
print_line_number	nvim/ag/src/print.c	/^void print_line_number(size_t line, const char sep) {$/;"	f
print_line_numbers	nvim/ag/src/options.h	/^    int print_line_numbers;$/;"	m	struct:__anon2
print_long_lines	nvim/ag/src/options.h	/^    int print_long_lines; \/* TODO: support this in print.c *\/$/;"	m	struct:__anon2
print_mtx	nvim/ag/src/log.c	/^pthread_mutex_t print_mtx = PTHREAD_MUTEX_INITIALIZER;$/;"	v
print_nonmatching_files	nvim/ag/src/options.h	/^    int print_nonmatching_files;$/;"	m	struct:__anon2
print_path	nvim/ag/src/options.h	/^    int print_path;$/;"	m	struct:__anon2
print_path	nvim/ag/src/print.c	/^void print_path(const char *path, const char sep) {$/;"	f
print_path_count	nvim/ag/src/print.c	/^void print_path_count(const char *path, const char sep, const size_t count) {$/;"	f
print_trailing_context	nvim/ag/src/print.c	/^void print_trailing_context(const char *path, const char *buf, size_t n) {$/;"	f
print_version	nvim/ag/src/options.c	/^void print_version(void) {$/;"	f
printing_a_match	nvim/ag/src/print.c	/^    int printing_a_match;$/;"	m	struct:print_context	file:
query	nvim/ag/src/options.h	/^    char *query;$/;"	m	struct:__anon2
query_len	nvim/ag/src/options.h	/^    int query_len;$/;"	m	struct:__anon2
re	nvim/ag/src/options.h	/^    pcre *re;$/;"	m	struct:__anon2
re_extra	nvim/ag/src/options.h	/^    pcre_extra *re_extra;$/;"	m	struct:__anon2
realloc_matches	nvim/ag/src/util.c	/^void realloc_matches(match_t **matches, size_t *matches_size, size_t matches_len) {$/;"	f
realpath	nvim/ag/src/util.c	/^char *realpath(const char *path, char *resolved_path) {$/;"	f
recurse_dirs	nvim/ag/src/options.h	/^    int recurse_dirs;$/;"	m	struct:__anon2
regexes	nvim/ag/src/ignore.h	/^    char **regexes; \/* For patterns that need fnmatch *\/$/;"	m	struct:ignores
regexes_len	nvim/ag/src/ignore.h	/^    size_t regexes_len;$/;"	m	struct:ignores
root_ignores	nvim/ag/src/ignore.c	/^ignores *root_ignores;$/;"	v
run_sanitizer	nvim/ag/sanitize.sh	/^run_sanitizer() {$/;"	f
run_valgrind	nvim/ag/sanitize.sh	/^run_valgrind() {$/;"	f
scandir_baton_t	nvim/ag/src/scandir.h	/^} scandir_baton_t;$/;"	t	typeref:struct:__anon9
search_all_files	nvim/ag/src/options.h	/^    int search_all_files;$/;"	m	struct:__anon2
search_binary_files	nvim/ag/src/options.h	/^    int search_binary_files;$/;"	m	struct:__anon2
search_buf	nvim/ag/src/search.c	/^ssize_t search_buf(const char *buf, const size_t buf_len,$/;"	f
search_dir	nvim/ag/src/search.c	/^void search_dir(ignores *ig, const char *base_path, const char *path, const int depth,$/;"	f
search_file	nvim/ag/src/search.c	/^void search_file(const char *file_full_path) {$/;"	f
search_file_worker	nvim/ag/src/search.c	/^void *search_file_worker(void *i) {$/;"	f
search_hidden_files	nvim/ag/src/options.h	/^    int search_hidden_files;$/;"	m	struct:__anon2
search_stream	nvim/ag/src/options.h	/^    int search_stream; \/* true if tail -F blah | ag *\/$/;"	m	struct:__anon2
search_stream	nvim/ag/src/search.c	/^ssize_t search_stream(FILE *stream, const char *path) {$/;"	f
search_zip_files	nvim/ag/src/options.h	/^    int search_zip_files;$/;"	m	struct:__anon2
set_log_level	nvim/ag/src/log.c	/^void set_log_level(enum log_level threshold) {$/;"	f
signature	nvim/ag/src/uthash.h	/^    uint32_t signature; \/* used only to find hash tables in external analysis *\/$/;"	m	struct:UT_hash_table
skip_vcs_ignores	nvim/ag/src/options.h	/^    int skip_vcs_ignores;$/;"	m	struct:__anon2
slash_names	nvim/ag/src/ignore.h	/^    char **slash_names; \/* Same but starts with a slash *\/$/;"	m	struct:ignores
slash_names_len	nvim/ag/src/ignore.h	/^    size_t slash_names_len;$/;"	m	struct:ignores
slash_regexes	nvim/ag/src/ignore.h	/^    char **slash_regexes;$/;"	m	struct:ignores
slash_regexes_len	nvim/ag/src/ignore.h	/^    size_t slash_regexes_len;$/;"	m	struct:ignores
sp	nvim/init.vim	/^nmap sp :split<cr>$/;"	m
start	nvim/ag/src/util.h	/^    size_t start; \/* Byte at which the match starts *\/$/;"	m	struct:__anon6
stats	nvim/ag/src/options.h	/^    int stats;$/;"	m	struct:__anon2
stats	nvim/ag/src/util.c	/^ag_stats stats;$/;"	v
stats_mtx	nvim/ag/src/search.c	/^pthread_mutex_t stats_mtx = PTHREAD_MUTEX_INITIALIZER;$/;"	v
stdout_inode	nvim/ag/src/options.h	/^    ino_t stdout_inode;$/;"	m	struct:__anon2
stream	nvim/ag/src/zfile.c	/^    } stream;$/;"	m	struct:zfile	typeref:union:zfile::__anon1	file:
stream_line_num	nvim/ag/src/options.h	/^    size_t stream_line_num; \/* This should totally not be in here *\/$/;"	m	struct:__anon2
strlcpy	nvim/ag/src/util.c	/^size_t strlcpy(char *dst, const char *src, size_t size) {$/;"	f
suffix_len	nvim/ag/src/util.c	/^size_t suffix_len(const char *s, const size_t s_len, const size_t pos, const int case_sensitive) {$/;"	f
symdir_t	nvim/ag/src/search.h	/^} symdir_t;$/;"	t	typeref:struct:__anon11
symhash	nvim/ag/src/search.c	/^symdir_t *symhash = NULL;$/;"	v
sys	nvim/ag/tests/big/create_big_file.py	/^import sys$/;"	i
tail	nvim/ag/src/uthash.h	/^    struct UT_hash_handle *tail; \/* tail hh in app order, for fast append    *\/$/;"	m	struct:UT_hash_table	typeref:struct:UT_hash_table::UT_hash_handle
tbl	nvim/ag/src/uthash.h	/^    struct UT_hash_table *tbl;$/;"	m	struct:UT_hash_handle	typeref:struct:UT_hash_handle::UT_hash_table
thread	nvim/ag/src/main.c	/^    pthread_t thread;$/;"	m	struct:__anon4	file:
time_end	nvim/ag/src/util.h	/^    struct timeval time_end;$/;"	m	struct:__anon7	typeref:struct:__anon7::timeval
time_start	nvim/ag/src/util.h	/^    struct timeval time_start;$/;"	m	struct:__anon7	typeref:struct:__anon7::timeval
total_bytes	nvim/ag/src/util.h	/^    size_t total_bytes;$/;"	m	struct:__anon7
total_file_matches	nvim/ag/src/util.h	/^    size_t total_file_matches;$/;"	m	struct:__anon7
total_files	nvim/ag/src/util.h	/^    size_t total_files;$/;"	m	struct:__anon7
total_matches	nvim/ag/src/util.h	/^    size_t total_matches;$/;"	m	struct:__anon7
truncate_marker	nvim/ag/src/print.c	/^const char *truncate_marker = " [...]";$/;"	v
uint32_t	nvim/ag/src/uthash.h	/^typedef unsigned int uint32_t;$/;"	t
uint8_t	nvim/ag/src/uthash.h	/^typedef unsigned char uint8_t;$/;"	t
usage	nvim/ag/format.sh	/^function usage() {$/;"	f
usage	nvim/ag/sanitize.sh	/^usage() {$/;"	f
usage	nvim/ag/src/options.c	/^void usage(void) {$/;"	f
use_thread_affinity	nvim/ag/src/options.h	/^    int use_thread_affinity;$/;"	m	struct:__anon2
uthash_expand_fyi	nvim/ag/src/uthash.h	/^#define uthash_expand_fyi(/;"	d
uthash_fatal	nvim/ag/src/uthash.h	/^#define uthash_fatal(/;"	d
uthash_free	nvim/ag/src/uthash.h	/^#define uthash_free(/;"	d
uthash_malloc	nvim/ag/src/uthash.h	/^#define uthash_malloc(/;"	d
uthash_noexpand_fyi	nvim/ag/src/uthash.h	/^#define uthash_noexpand_fyi(/;"	d
valid_sanitizer	nvim/ag/sanitize.sh	/^valid_sanitizer() {$/;"	f
vasprintf	nvim/ag/src/util.c	/^int vasprintf(char **ret, const char *fmt, va_list args) {$/;"	f
vimgrep	nvim/ag/src/options.h	/^    int vimgrep;$/;"	m	struct:__anon2
vplog	nvim/ag/src/log.c	/^void vplog(const unsigned int level, const char *fmt, va_list args) {$/;"	f
vrun	nvim/ag/sanitize.sh	/^vrun() {$/;"	f
vs	nvim/init.vim	/^nmap vs :vsplit<cr>$/;"	m
width	nvim/ag/src/options.h	/^    size_t width;$/;"	m	struct:__anon2
windows_use_ansi	nvim/ag/src/print_w32.c	/^void windows_use_ansi(int use_ansi) {$/;"	f
word_regexp	nvim/ag/src/options.h	/^    int word_regexp;$/;"	m	struct:__anon2
word_t	nvim/ag/src/util.h	/^} word_t;$/;"	t	typeref:union:__anon8
wordchar_table	nvim/ag/src/util.c	/^static int wordchar_table[256];$/;"	v	file:
work_queue	nvim/ag/src/search.c	/^work_queue_t *work_queue = NULL;$/;"	v
work_queue_mtx	nvim/ag/src/search.c	/^pthread_mutex_t work_queue_mtx = PTHREAD_MUTEX_INITIALIZER;$/;"	v
work_queue_t	nvim/ag/src/search.h	/^struct work_queue_t {$/;"	s
work_queue_t	nvim/ag/src/search.h	/^typedef struct work_queue_t work_queue_t;$/;"	t	typeref:struct:work_queue_t
work_queue_tail	nvim/ag/src/search.c	/^work_queue_t *work_queue_tail = NULL;$/;"	v
worker_t	nvim/ag/src/main.c	/^} worker_t;$/;"	t	typeref:struct:__anon4	file:
workers	nvim/ag/src/options.h	/^    int workers;$/;"	m	struct:__anon2
zfile	nvim/ag/src/zfile.c	/^struct zfile {$/;"	s	file:
zfile_close	nvim/ag/src/zfile.c	/^static cookie_close_function_t zfile_close;$/;"	v	file:
zfile_close	nvim/ag/src/zfile.c	/^zfile_close(void *cookie_) {$/;"	f	file:
zfile_cookie_cleanup	nvim/ag/src/zfile.c	/^zfile_cookie_cleanup(struct zfile *cookie) {$/;"	f	file:
zfile_cookie_init	nvim/ag/src/zfile.c	/^zfile_cookie_init(struct zfile *cookie) {$/;"	f	file:
zfile_io	nvim/ag/src/zfile.c	/^static const cookie_io_functions_t zfile_io = {$/;"	v	file:
zfile_read	nvim/ag/src/zfile.c	/^static cookie_read_function_t zfile_read;$/;"	v	file:
zfile_read	nvim/ag/src/zfile.c	/^zfile_read(void *cookie_, char *buf, size_t size) {$/;"	f	file:
zfile_seek	nvim/ag/src/zfile.c	/^static cookie_seek_function_t zfile_seek;$/;"	v	file:
zfile_seek	nvim/ag/src/zfile.c	/^zfile_seek(void *cookie_, off64_t *offset_, int whence) {$/;"	f	file:
